"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildConfig = void 0;
const utils_1 = require("../utils");
const helpers_1 = require("../helpers");
const virtualModuleIdPageFiles_1 = require("./virtualFiles/virtualModuleIdPageFiles");
const getPageConfigsData_1 = require("./virtualFiles/generatePageConfigsSourceCode/getPageConfigsData");
const utils_2 = require("../../../shared/page-configs/utils");
function buildConfig() {
    return {
        name: 'vite-plugin-ssr:buildConfig',
        apply: 'build',
        enforce: 'post',
        async configResolved(config) {
            const input = {
                ...(await getEntries(config)),
                ...normalizeRollupInput(config.build.rollupOptions.input)
            };
            config.build.rollupOptions.input = input;
            addLogHook();
        },
        config(config) {
            return {
                build: {
                    outDir: (0, utils_1.determineOutDir)(config),
                    manifest: !(0, utils_1.viteIsSSR)(config),
                    polyfillDynamicImport: false
                },
                ssr: { external: ['vite-plugin-ssr'] }
                /* We cannot do this because of https://github.com/brillout/vite-plugin-ssr/issues/447
                plublicDir: !viteIsSSR(config),
                */
            };
        }
    };
}
exports.buildConfig = buildConfig;
async function getEntries(config) {
    const pageFileEntries = await getPageFileEntries(config); // TODO/v1-release: remove
    let { hasClientRouting, hasServerRouting, clientEntries } = await analyzeAppRouting(config);
    if (Object.entries(pageFileEntries).length > 0) {
        hasClientRouting = true;
        hasServerRouting = true;
    }
    if ((0, utils_1.viteIsSSR)(config)) {
        return {
            // We don't add the page files because it seems to be a breaking change for the internal Vite plugin `vite:dep-scan` (not sure why?). It then throws an error `No known conditions for "./server" entry in "react-streaming" package` where it previously didn't.
            // ...pageFileEntries,
            pageFiles: virtualModuleIdPageFiles_1.virtualModuleIdPageFilesServer,
            importBuild: resolve('dist/cjs/node/importBuild.js')
        };
    }
    else {
        const entries = {
            ...clientEntries,
            ...pageFileEntries
        };
        const clientRoutingEntry = resolve(`dist/esm/client/router/entry.js`);
        const serverRoutingEntry = resolve(`dist/esm/client/entry.js`);
        if (hasClientRouting) {
            entries['entry-client-routing'] = clientRoutingEntry;
        }
        if (hasServerRouting) {
            entries['entry-server-routing'] = serverRoutingEntry;
        }
        return entries;
    }
}
async function analyzeAppRouting(config) {
    const { pageConfigsData } = await (0, getPageConfigsData_1.loadPageConfigsData)(config.root, false);
    let hasClientRouting = false;
    let hasServerRouting = false;
    let clients = [];
    pageConfigsData.forEach((pageConfigData) => {
        const clientRouting = (0, utils_2.getConfigValue)(pageConfigData, 'clientRouting', 'boolean');
        if (clientRouting) {
            hasClientRouting = true;
        }
        else {
            hasServerRouting = true;
        }
        const clientEntry = (0, utils_2.getCodeFilePath)(pageConfigData, 'clientEntry');
        if (clientEntry) {
            clients.push(clientEntry);
        }
    });
    const clientEntries = formatEntries(clients, config);
    return { hasClientRouting, hasServerRouting, clientEntries };
}
// Ensure Rollup creates entries for each page file, see https://github.com/brillout/vite-plugin-ssr/issues/350
// (Otherwise the page files may be missing in the client manifest.json)
async function getPageFileEntries(config) {
    const pageFiles = await (0, helpers_1.findPageFiles)(config, (0, utils_1.viteIsSSR)(config) ? ['.page', '.page.server'] : ['.page', '.page.client']);
    const pageFileEntries = formatEntries(pageFiles, config);
    return pageFileEntries;
}
function formatEntries(entryList, config) {
    entryList = (0, utils_1.unique)(entryList);
    const entries = {};
    entryList.forEach((p) => (entries[(0, utils_1.removeFileExtention)(p.slice(1))] = (0, utils_1.makeFilePathAbsolute)(p, config)));
    return entries;
}
function resolve(filePath) {
    (0, utils_1.assert)(filePath.startsWith('dist/'));
    // [RELATIVE_PATH_FROM_DIST] Current directory: node_modules/vite-plugin-ssr/dist/cjs/node/plugin/plugins/
    return require.resolve(`../../../../../${filePath}`);
}
function normalizeRollupInput(input) {
    if (!input) {
        return {};
    }
    // Usually `input` is an oject, but the user can set it as a `string` or `string[]`
    if (typeof input === 'string') {
        input = [input];
    }
    if (Array.isArray(input)) {
        return Object.fromEntries(input.map((input) => [input, input]));
    }
    (0, utils_1.assert)((0, utils_1.isObject)(input));
    return input;
}
function addLogHook() {
    const tty = process.stdout.isTTY && !process.env.CI; // Equals https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts#L27
    if (!tty)
        return;
    let lastLog = null;
    ['stdout', 'stderr'].forEach((stdName) => {
        var methodOriginal = process[stdName].write;
        process[stdName].write = function (...args) {
            lastLog = String(args[0]);
            return methodOriginal.apply(process[stdName], args);
        };
    });
    // Exhaustive list extracted from writeLine() calls at https://github.com/vitejs/vite/blob/193d55c7b9cbfec5b79ebfca276d4a721e7de14d/packages/vite/src/node/plugins/reporter.ts
    // prettier-ignore
    const viteTransientLogs = [
        'transforming (',
        'rendering chunks (',
        'computing gzip size ('
    ];
    (0, utils_1.addOnBeforeLogHook)(() => {
        // Using viteTransientLogs is very conservative as clearing the current line is low risk. (We can assume that important messages, such as errors, include a trailing new line. Usually, only transient messages have no trailing new lines.)
        if (viteTransientLogs.some((s) => lastLog?.startsWith(s))) {
            process.stdout.clearLine(0);
            process.stdout.cursorTo(0);
        }
    });
}
