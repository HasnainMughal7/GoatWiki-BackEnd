"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configDefinitionsBuiltIn = void 0;
const utils_1 = require("../../../utils");
const resolveRouteString_1 = require("../../../../../shared/route/resolveRouteString");
const configDefinitionsBuiltIn = {
    onRenderHtml: {
        c_code: true,
        c_required: true,
        c_env: 'server-only'
    },
    onRenderClient: {
        c_code: true,
        c_env: 'client-only'
    },
    onHydrationEnd: {
        c_code: true,
        c_env: 'client-only'
    },
    onPageTransitionStart: {
        c_code: true,
        c_env: 'client-only'
    },
    onPageTransitionEnd: {
        c_code: true,
        c_env: 'client-only'
    },
    onBeforeRender: {
        c_code: true,
        c_env: 'server-only'
    },
    onPrerender: {
        c_code: true,
        c_env: 'server-only'
    },
    Page: {
        c_code: true,
        c_env: 'server-and-client'
    },
    passToClient: {
        c_env: 'server-only'
    },
    route: {
        c_env: 'c_routing',
        c_validate: getRouteValidator()
    },
    iKnowThePerformanceRisksOfAsyncRouteFunctions: {
        c_env: 'server-and-client'
    },
    // TODO: rename to 'client'? I think so if client is cumulative to onRenderClient (while HTML-only needs to set `onRenderClient: null`)
    clientEntry: {
        c_code: true,
        c_env: 'client-only'
    },
    clientRouting: {
        c_env: 'server-and-client' // TODO: c_config instead?
    },
    prerender: {
        c_env: 'c_config'
    },
    hydrationCanBeAborted: {
        c_env: 'client-only' // TODO: c_config instead?
    },
    isErrorPage: {
        c_env: 'c_config' // TODO: c_config instead?
    }
    /* TODO
    onBeforeRoute: {
      c_code: true,
      c_global: true,
      c_env: 'c_routing'
    }
    onBeforePrerender: {
      c_code: true,
      c_global: true,
      c_env: 'server-only'
    }
    */
};
exports.configDefinitionsBuiltIn = configDefinitionsBuiltIn;
function getRouteValidator() {
    const validateRoute = (configResolved) => {
        const { configFilePath, configValue } = configResolved;
        if ('codeFilePath' in configResolved)
            return;
        if (typeof configValue === 'string') {
            (0, resolveRouteString_1.assertRouteString)(configValue, `${configFilePath} defines an`);
        }
        else {
            if ((0, utils_1.isCallable)(configValue)) {
                const routeFunctionName = configValue.name || 'myRouteFunction';
                // TODO/v1: point to https://vite-plugin-ssr.com/route-function
                // TODO: write https://vite-plugin-ssr.com/v1-design
                (0, utils_1.assertUsage)(false, `${configFilePath} sets a Route Function directly \`route: function ${routeFunctionName}() { /* ... */ }\` which is forbidden: instead define a file \`route: './path/to/route-file.js'\` that exports your Route Function \`export default ${routeFunctionName}() { /* ... */ }\`. See https://vite-plugin-ssr.com/v1-design for more information.`);
            }
            // TODO/v1: point to https://vite-plugin-ssr.com/routing#route-strings-route-functions
            // TODO: write https://vite-plugin-ssr.com/v1-design
            (0, utils_1.assertUsage)(false, `${configFilePath} sets the configuration 'route' to a value with an invalid type \`${typeof configValue}\`: the value should be a string (a Route String or the path of a route file exporting a Route Function). See https://vite-plugin-ssr.com/v1-design for more information.`);
        }
    };
    return validateRoute;
}
