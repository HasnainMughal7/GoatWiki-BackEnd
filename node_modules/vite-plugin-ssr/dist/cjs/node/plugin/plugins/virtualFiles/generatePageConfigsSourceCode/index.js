"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.generatePageConfigVirtualFile = exports.generatePageConfigsSourceCode = void 0;
const utils_1 = require("../../../utils");
const generateEagerImport_1 = require("../generateEagerImport");
const virtualIdPageCodeFilesImporter_1 = require("../../../../commons/virtualIdPageCodeFilesImporter");
const getPageConfigsData_1 = require("./getPageConfigsData");
let pageConfigsData = null;
// TODO remove old debug:glob
exports.debug = (0, utils_1.createDebugger)('vps:virtual-files');
// TODO: ensure that client-side of Server Routing loads less than Client Routing
// TODO: create one virtual file per route
// TODO: if conf isn't file path then assert that it's serialazable
// TODO: use Math.random() instead of timestamp in built file + think why I had concurrent issues
// TODO: Improve Vite error logging when:
//       ```
//        /pages/+config.ts sets the config onRenderHtml to the value './+config/onRenderHtml.js' but a file wasn't found at /home/rom/code/vite-plugin-ssr/examples/vanilla-v1/pages/+config/onRenderHtml.js
//       ```
// TODO: comment https://github.com/reactjs/reactjs.org/pull/5487#issuecomment-1409720741
// TODO: Define pageContext.pageId
// TODO: Check/improve dist/ names
// TODO: export type { Config } for users
// TODO: improve Vite dev error handling upon user setting unknown config
// TODO: assertUsage isErrorPage not allowed to be abstract
// TODO: check whether onBeforerRender() is isomorph or server-only in react-full-v1 example
// TODO: rename configSrc/configSource to configDefinedBy
// TODO: check error handling when no onRenderHtml defined
async function generatePageConfigsSourceCode(userRootDir, isForClientSide, isDev) {
    const result = await (0, getPageConfigsData_1.loadPageConfigsData)(userRootDir, isDev);
    pageConfigsData = result.pageConfigsData;
    const { pageConfigGlobal } = result;
    return generateSourceCodeOfPageConfigs(pageConfigsData, pageConfigGlobal, isForClientSide, isDev);
}
exports.generatePageConfigsSourceCode = generatePageConfigsSourceCode;
function generateSourceCodeOfPageConfigs(pageConfigsData, pageConfigGlobal, isForClientSide, isDev) {
    const lines = [];
    const importStatements = [];
    lines.push('export const pageConfigs = [];');
    // const configNamesAll = new Set<string>()
    pageConfigsData.forEach((pageConfig, i) => {
        const { pageConfigFilePathAll, pageId2, routeFilesystem, routeFilesystemDefinedBy, configSources, isErrorPage } = pageConfig;
        const codeFilesImporter = (0, virtualIdPageCodeFilesImporter_1.getVirutalModuleIdPageCodeFilesImporter)(pageId2, isForClientSide);
        const pageConfigVar = `pageConfig${i + 1}`; // TODO: remove outdated & unncessary variable creation
        lines.push(`{`);
        lines.push(`  const ${pageConfigVar} = {`);
        lines.push(`    pageId2: ${JSON.stringify(pageId2)},`);
        lines.push(`    isErrorPage: ${JSON.stringify(isErrorPage)},`);
        lines.push(`    pageConfigFilePathAll: ${JSON.stringify(pageConfigFilePathAll)},`);
        lines.push(`    routeFilesystem: ${JSON.stringify(routeFilesystem)},`);
        lines.push(`    routeFilesystemDefinedBy: ${JSON.stringify(routeFilesystemDefinedBy)},`);
        lines.push(`    loadCodeFiles: async () => (await import(${JSON.stringify(codeFilesImporter)})).default,`);
        lines.push(`    configSources: {`);
        Object.entries(configSources).forEach(([configName, configSource]) => {
            // configNamesAll.add(configName)
            lines.push(`      ['${configName}']: {`);
            const { configSrc, configDefinedByFile, c_env, codeFilePath2, configFilePath2 } = configSource;
            lines.push(`        configSrc: ${JSON.stringify(configSrc)},`);
            lines.push(`        configDefinedByFile: ${JSON.stringify(configDefinedByFile)},`);
            lines.push(`        codeFilePath2: ${JSON.stringify(codeFilePath2)},`);
            lines.push(`        configFilePath2: ${JSON.stringify(configFilePath2)},`);
            lines.push(`        c_env: '${c_env}',`);
            if ('configValue' in configSource) {
                const { configValue } = configSource;
                lines.push(`        configValue: ${JSON.stringify(configValue)}`);
            }
            else {
                (0, utils_1.assert)(configSource.codeFilePath2);
                const { codeFilePath2, c_env } = configSource;
                if (c_env === 'c_routing') {
                    const { importVar, importStatement } = (0, generateEagerImport_1.generateEagerImport)(codeFilePath2);
                    // TODO: expose all exports so that assertDefaultExport() can be applied
                    lines.push(`        configValue: ${importVar}.default`);
                    importStatements.push(importStatement);
                }
            }
            lines.push(`      },`);
        });
        lines.push(`    }`);
        lines.push('  };');
        lines.push(`  pageConfigs.push(${pageConfigVar})`);
        lines.push(`}`);
    });
    lines.push('export const pageConfigGlobal = {');
    Object.entries(pageConfigGlobal).forEach(([configName, configValue]) => {
        lines.push(`['${configName}']: ${configValue}`);
    });
    lines.push('};');
    if (isDev) {
        lines.push(getInvalidatorGlob(isDev));
    }
    else {
        lines.push('export const plusFilesGlob = null;');
    }
    // TODO: remove
    // lines.push('import.meta.glob([')
    // ;['config', ...configNamesAll].forEach((configName) => {
    //   lines.push(`'/**/+${configName}.${scriptFileExtensions}',`)
    // })
    // lines.push(']);')
    const code = [...importStatements, ...lines].join('\n');
    return code;
}
async function generatePageConfigVirtualFile(id, isForClientSide, userRootDir, isDev) {
    const result = (0, virtualIdPageCodeFilesImporter_1.isVirutalModulePageCodeFilesImporter)(id);
    if (!result)
        return null;
    (0, utils_1.assert)(result.isForClientSide === isForClientSide);
    const { pageId } = result;
    if (!pageConfigsData) {
        const result = await (0, getPageConfigsData_1.loadPageConfigsData)(userRootDir, isDev);
        pageConfigsData = result.pageConfigsData;
    }
    (0, utils_1.assert)(pageConfigsData);
    const pageConfigData = pageConfigsData.find((pageConfigData) => pageConfigData.pageId2 === pageId);
    (0, utils_1.assert)(pageConfigData);
    const code = generateSourceCodeOfLoadCodeFileVirtualFile(pageConfigData, isForClientSide, isDev);
    (0, exports.debug)(id, isForClientSide ? 'CLIENT-SIDE' : 'SERVER-SIDE', code);
    return code;
}
exports.generatePageConfigVirtualFile = generatePageConfigVirtualFile;
function generateSourceCodeOfLoadCodeFileVirtualFile(pageConfigData, isForClientSide, isDev) {
    const lines = [];
    const importStatements = [];
    lines.push('export default [');
    let varCounter = 0;
    Object.entries(pageConfigData.configSources).forEach(([configName, configSource]) => {
        if (!configSource.codeFilePath2)
            return;
        const { c_env, codeFilePath2 } = configSource;
        if (c_env === 'c_routing' || c_env === 'c_config')
            return;
        if (c_env === (isForClientSide ? 'server-only' : 'client-only'))
            return;
        const { importVar, importStatement } = (0, generateEagerImport_1.generateEagerImport)(codeFilePath2, varCounter++);
        importStatements.push(importStatement);
        lines.push(`  {`);
        lines.push(`    configName: '${configName}',`);
        lines.push(`    codeFilePath3: '${codeFilePath2}',`);
        lines.push(`    codeFileExports: ${importVar}`);
        lines.push(`  },`);
    });
    lines.push('];');
    if (isDev) {
        lines.push(getInvalidatorGlob(isDev));
    }
    const code = [...importStatements, ...lines].join('\n');
    return code;
}
function getInvalidatorGlob(isDev) {
    (0, utils_1.assert)(isDev);
    // The crawled files are never loaded (the plusFilesGlob export isn't used), the only effect of this glob is to invalidate the virtual module.
    // We agressively invalidate the virual files because they are cheap and fast to re-create.
    return "export const plusFilesGlob = import.meta.glob('/**/+*');";
}
