"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPageConfigsData = void 0;
const deduceRouteStringFromFilesystemPath_1 = require("../../../../../shared/route/deduceRouteStringFromFilesystemPath");
const utils_1 = require("../../../utils");
const path_1 = __importDefault(require("path"));
const configDefinitionsBuiltIn_1 = require("./configDefinitionsBuiltIn");
const fast_glob_1 = __importDefault(require("fast-glob"));
async function loadPageConfigsData(userRootDir, isDev) {
    const result = await findAndLoadPageConfigFiles1(userRootDir);
    /* TODO: - remove this if we don't need this for optimizeDeps.entries
     *       - also remove whole result.err try-catch mechanism, just let esbuild throw instead
    if ('err' in result) {
      return ['export const pageConfigs = null;', 'export const pageConfigGlobal = null;'].join('\n')
    }
    */
    if ('err' in result) {
        handleBuildError(result.err, isDev);
        (0, utils_1.assert)(false);
    }
    const { pageConfigFiles } = result;
    let configValueFiles;
    {
        const configDefinitionsAll = getConfigDefinitions(pageConfigFiles);
        configValueFiles = await findAndLoadConfigValueFiles(configDefinitionsAll, userRootDir);
    }
    const pageConfigGlobal = {};
    const pageConfigsData = [];
    const pageIds = [];
    pageConfigFiles
        .filter((p) => isDefiningPage(p))
        .forEach((pageConfigFile) => {
        const { pageConfigFilePath } = pageConfigFile;
        const pageId2 = (0, deduceRouteStringFromFilesystemPath_1.determinePageId2)(pageConfigFilePath);
        const routeFilesystem = (0, deduceRouteStringFromFilesystemPath_1.determineRouteFromFilesystemPath)(pageConfigFilePath);
        pageIds.push({
            pageId2,
            routeFilesystem,
            pageConfigFile,
            routeFilesystemDefinedBy: pageConfigFilePath
        });
    });
    configValueFiles.map(({ configValueFilePath }) => {
        const pageId2 = (0, deduceRouteStringFromFilesystemPath_1.determinePageId2)(configValueFilePath);
        const routeFilesystem = (0, deduceRouteStringFromFilesystemPath_1.determineRouteFromFilesystemPath)(configValueFilePath);
        (0, utils_1.assertPosixPath)(configValueFilePath);
        const routeFilesystemDefinedBy = path_1.default.posix.dirname(configValueFilePath) + '/';
        (0, utils_1.assert)(!routeFilesystemDefinedBy.endsWith('//'));
        {
            const alreadyIncluded = pageIds.some((p) => {
                if (p.pageId2 === pageId2) {
                    (0, utils_1.assert)(p.routeFilesystem === routeFilesystem);
                    return true;
                }
                return false;
            });
            if (alreadyIncluded)
                return;
        }
        pageIds.push({
            pageId2,
            routeFilesystem,
            pageConfigFile: null,
            routeFilesystemDefinedBy
        });
    });
    pageIds.forEach(({ pageId2, routeFilesystem, pageConfigFile, routeFilesystemDefinedBy }) => {
        const pageConfigFilesRelevant = getPageConfigFilesRelevant(pageId2, pageConfigFiles);
        const configValueFilesRelevant = configValueFiles.filter((c) => c.pageId === pageId2);
        let configDefinitionsRelevant = getConfigDefinitions(pageConfigFilesRelevant);
        if (pageConfigFile) {
            const pageConfigValues = getPageConfigValues(pageConfigFile);
            Object.keys(pageConfigValues).forEach((configName) => {
                // TODO: this applies only against concrete config files, we should also apply to abstract config files
                (0, utils_1.assertUsage)(configName in configDefinitionsRelevant || configName === 'configDefinitions', `${pageConfigFile.pageConfigFilePath} defines an unknown config '${configName}'`);
            });
        }
        configValueFilesRelevant.forEach((configValueFile) => {
            const { configName, configValueFilePath } = configValueFile;
            (0, utils_1.assertUsage)(configName in configDefinitionsRelevant || configName === 'configDefinitions', `${configValueFilePath} defines an unknown config '${configName}'`);
        });
        let configSources = {};
        (0, utils_1.objectEntries)(configDefinitionsRelevant).forEach(([configName, configDef]) => {
            const configSource = resolveConfigSource(configName, configDef, pageConfigFilesRelevant, userRootDir, configValueFilesRelevant);
            if (!configSource)
                return;
            configSources[configName] = configSource;
        });
        configSources = applySideEffects(configSources, configDefinitionsRelevant);
        const isErrorPage = !!configSources.isErrorPage?.configValue;
        pageConfigsData.push({
            pageId2,
            isErrorPage,
            routeFilesystemDefinedBy,
            pageConfigFilePathAll: pageConfigFilesRelevant.map((p) => p.pageConfigFilePath),
            routeFilesystem: isErrorPage ? null : routeFilesystem,
            configSources
        });
    });
    return { pageConfigsData, pageConfigGlobal };
}
exports.loadPageConfigsData = loadPageConfigsData;
function resolveConfigSource(configName, configDef, pageConfigFilesRelevant, userRootDir, configValueFilesRelevant) {
    // TODO: implement warning if defined in non-abstract +config.js as well as in +{configName}.js
    {
        const configValueFiles = configValueFilesRelevant.filter((configValueFile) => configValueFile.configName === configName);
        if (configValueFiles.length !== 0) {
            (0, utils_1.assert)(configValueFiles.length === 1);
            const configValueFile = configValueFiles[0];
            const { configValueFilePath } = configValueFile;
            const configSource = {
                c_env: configDef.c_env,
                // TODO: rename codeFilePath2 to configValueFilePath?
                codeFilePath2: configValueFilePath,
                configFilePath2: null,
                configSrc: `${configValueFilePath} > \`export default\``,
                configDefinedByFile: configValueFilePath
            };
            if ('configValue' in configValueFile) {
                configSource.configValue = configValueFile.configValue;
            }
            return configSource;
        }
    }
    const result = getConfigValue(configName, pageConfigFilesRelevant);
    if (!result)
        return null;
    const { pageConfigValue, pageConfigValueFilePath } = result;
    const configValue = pageConfigValue;
    const configFilePath = pageConfigValueFilePath;
    const { c_code, c_validate } = configDef;
    const codeFilePath = getCodeFilePath(pageConfigValue, pageConfigValueFilePath, userRootDir, configName, c_code);
    (0, utils_1.assert)(codeFilePath || !c_code); // TODO: assertUsage() or remove
    if (c_validate) {
        const commonArgs = { configFilePath };
        if (codeFilePath) {
            (0, utils_1.assert)(typeof configValue === 'string');
            c_validate({ configValue, codeFilePath, ...commonArgs });
        }
        else {
            c_validate({ configValue, ...commonArgs });
        }
    }
    const { c_env } = configDef;
    if (!codeFilePath) {
        return {
            configFilePath2: configFilePath,
            configSrc: `${configFilePath} > ${configName}`,
            configDefinedByFile: configFilePath,
            codeFilePath2: null,
            c_env,
            configValue
        };
    }
    else {
        (0, utils_1.assertUsage)(typeof configValue === 'string', `${getErrorIntro(configFilePath, configName)} to a value with a wrong type \`${typeof configValue}\`: it should be a string instead`);
        return {
            configFilePath2: configFilePath,
            codeFilePath2: codeFilePath,
            configSrc: `${codeFilePath} > \`export default\``,
            configDefinedByFile: codeFilePath,
            c_env
        };
    }
}
function isDefiningPage(pageConfigFile) {
    const pageConfigValues = getPageConfigValues(pageConfigFile);
    return !!pageConfigValues.Page || !!pageConfigValues.route || !!pageConfigValues.isErrorPage;
}
function getCodeFilePath(configValue, pageConfigFilePath, userRootDir, configName, enforce) {
    if (typeof configValue !== 'string') {
        (0, utils_1.assertUsage)(!enforce, `${getErrorIntro(pageConfigFilePath, configName)} to a value with an invalid type \`${typeof configValue}\` but it should be a \`string\` instead`);
        return null;
    }
    let codeFilePath = getVitePathFromConfigValue((0, utils_1.toPosixPath)(configValue), pageConfigFilePath);
    (0, utils_1.assertPosixPath)(userRootDir);
    (0, utils_1.assertPosixPath)(codeFilePath);
    codeFilePath = path_1.default.posix.join(userRootDir, codeFilePath);
    const clean = (0, utils_1.addFileExtensionsToRequireResolve)();
    let fileExists;
    try {
        codeFilePath = require.resolve(codeFilePath);
        fileExists = true;
    }
    catch {
        fileExists = false;
    }
    finally {
        clean();
    }
    codeFilePath = (0, utils_1.toPosixPath)(codeFilePath);
    if (!enforce && !fileExists)
        return null;
    assertCodeFilePathConfigValue(configValue, pageConfigFilePath, codeFilePath, fileExists, configName);
    // Make relative to userRootDir
    codeFilePath = getVitePathFromAbsolutePath(codeFilePath, userRootDir);
    (0, utils_1.assert)(fileExists);
    (0, utils_1.assertPosixPath)(codeFilePath);
    (0, utils_1.assert)(codeFilePath.startsWith('/'));
    return codeFilePath;
}
function assertCodeFilePathConfigValue(configValue, pageConfigFilePath, codeFilePath, fileExists, configName) {
    const errIntro = getErrorIntro(pageConfigFilePath, configName);
    const errIntro1 = `${errIntro} to the value '${configValue}'`;
    const errIntro2 = `${errIntro1} but the value should be`;
    const warnArgs = { onlyOnce: true, showStackTrace: false };
    (0, utils_1.assertUsage)(fileExists, `${errIntro1} but a file wasn't found at ${codeFilePath}`);
    let configValueFixed = configValue;
    if (!(0, utils_1.isPosixPath)(configValueFixed)) {
        (0, utils_1.assert)(configValueFixed.includes('\\'));
        configValueFixed = (0, utils_1.toPosixPath)(configValueFixed);
        (0, utils_1.assert)(!configValueFixed.includes('\\'));
        (0, utils_1.assertWarning)(false, `${errIntro2} '${configValueFixed}' instead (replace backslashes '\\' with forward slahes '/')`, warnArgs);
    }
    if (configValueFixed.startsWith('/')) {
        const pageConfigDir = dirnameNormalized(pageConfigFilePath);
        (0, utils_1.assertWarning)(false, `${errIntro2} a relative path instead (i.e. a path that starts with './' or '../') that is relative to ${pageConfigDir}`, warnArgs);
    }
    else if (!['./', '../'].some((prefix) => configValueFixed.startsWith(prefix))) {
        // It isn't possible to omit '../' so we can assume that the path is relative to pageConfigDir
        configValueFixed = './' + configValueFixed;
        (0, utils_1.assertWarning)(false, `${errIntro2} '${configValueFixed}' instead: make sure to prefix paths with './' (or '../')`, warnArgs);
    }
    {
        const filename = path_1.default.posix.basename(codeFilePath);
        configValueFixed = dirnameNormalized(configValueFixed) + filename;
        const fileExt = path_1.default.posix.extname(filename);
        (0, utils_1.assertWarning)(configValue.endsWith(filename), `${errIntro2} '${configValueFixed}' instead (don't omit the file extension '${fileExt}')`, warnArgs);
    }
}
function getVitePathFromConfigValue(codeFilePath, pageConfigFilePath) {
    const pageConfigDir = dirnameNormalized(pageConfigFilePath);
    if (!codeFilePath.startsWith('/')) {
        (0, utils_1.assertPosixPath)(codeFilePath);
        (0, utils_1.assertPosixPath)(pageConfigFilePath);
        codeFilePath = path_1.default.posix.join(pageConfigDir, codeFilePath);
    }
    (0, utils_1.assert)(codeFilePath.startsWith('/'));
    return codeFilePath;
}
function getVitePathFromAbsolutePath(filePathAbsolute, root) {
    (0, utils_1.assertPosixPath)(filePathAbsolute);
    (0, utils_1.assertPosixPath)(root);
    (0, utils_1.assert)(filePathAbsolute.startsWith(root));
    let vitePath = path_1.default.posix.relative(root, filePathAbsolute);
    (0, utils_1.assert)(!vitePath.startsWith('/') && !vitePath.startsWith('.'));
    vitePath = '/' + vitePath;
    return vitePath;
}
function dirnameNormalized(filePath) {
    (0, utils_1.assertPosixPath)(filePath);
    let fileDir = path_1.default.posix.dirname(filePath);
    (0, utils_1.assert)(!fileDir.endsWith('/'));
    fileDir = fileDir + '/';
    return fileDir;
}
function getErrorIntro(pageConfigFilePath, configName) {
    (0, utils_1.assert)(pageConfigFilePath.startsWith('/'));
    (0, utils_1.assert)(!configName.startsWith('/'));
    return `${pageConfigFilePath} sets the config ${configName}`;
}
function getConfigValue(pageConfigName, pageConfigFilesRelevant) {
    for (const configFile of pageConfigFilesRelevant) {
        const pageConfigValues = getPageConfigValues(configFile);
        const pageConfigValue = pageConfigValues[pageConfigName];
        if (pageConfigValue !== undefined) {
            return { pageConfigValueFilePath: configFile.pageConfigFilePath, pageConfigValue };
        }
    }
    return null;
}
function getPageConfigValues(pageConfigFile) {
    const { pageConfigFilePath, pageConfigFileExports } = pageConfigFile;
    (0, utils_1.assertDefaultExport)(pageConfigFileExports, pageConfigFilePath);
    const pageConfigValues = pageConfigFileExports.default;
    (0, utils_1.assertUsage)((0, utils_1.isObject)(pageConfigValues), `${pageConfigFilePath} should export an object (it exports a \`${typeof pageConfigValues}\` instead)`);
    return pageConfigValues;
}
function getConfigDefinitions(pageConfigFilesRelevant) {
    const configDefinitionsAll = { ...configDefinitionsBuiltIn_1.configDefinitionsBuiltIn };
    pageConfigFilesRelevant.forEach((pageConfigFile) => {
        const { pageConfigFilePath } = pageConfigFile;
        const { configDefinitions } = getPageConfigValues(pageConfigFile);
        if (configDefinitions) {
            (0, utils_1.assertUsage)((0, utils_1.isObject)(configDefinitions), `${pageConfigFilePath} sets the config 'configDefinitions' to a value with an invalid type \`${typeof configDefinitions}\`: it should be an object instead.`);
            (0, utils_1.objectEntries)(configDefinitions).forEach(([configName, configDefinition]) => {
                (0, utils_1.assertUsage)((0, utils_1.isObject)(configDefinition), `${pageConfigFilePath} sets 'configDefinitions.${configName}' to a value with an invalid type \`${typeof configDefinition}\`: it should be an object instead.`);
                // User can override an existing config definition
                const def = mergeConfigDefinition(configDefinitionsAll[configName], configDefinition);
                // Validation
                /* TODO
                {
                  {
                    const prop = 'c_env'
                    const hint = `Make sure to define the 'c_env' value of '${configName}' to 'client-only', 'server-only', or 'server-and-client'.`
                    assertUsage(
                      prop in def,
                      `${pageConfigFilePath} doesn't define 'configDefinitions.${configName}.c_env' which is required. ${hint}`
                    )
                    assertUsage(
                      hasProp(def, prop, 'string'),
                      `${pageConfigFilePath} sets 'configDefinitions.${configName}.c_env' to a value with an invalid type ${typeof def.c_env}. ${hint}`
                    )
                    assertUsage(
                      ['client-only', 'server-only', 'server-and-client'].includes(def.c_env),
                      `${pageConfigFilePath} sets 'configDefinitions.${configName}.c_env' to an invalid value '${def.c_env}'. ${hint}`
                    )
                  }
                }
                */
                configDefinitionsAll[configName] = def /* TODO: validate instead */;
            });
        }
    });
    return configDefinitionsAll;
}
function mergeConfigDefinition(def, mods) {
    return {
        ...def,
        ...mods
    };
}
function applySideEffects(configSources, configDefinitionsRelevant) {
    const configSourcesMod = { ...configSources };
    (0, utils_1.objectEntries)(configDefinitionsRelevant).forEach(([configName, configDef]) => {
        if (!configDef.sideEffect)
            return;
        (0, utils_1.assertUsage)(configDef.c_env === 'c_config', 'TODO');
        const configSourceSideEffect = configSources[configName];
        /*
        resolveConfigSource(
          configName,
          configDef,
          pageConfigFilesRelevant,
          userRootDir,
          configValueFilesRelevant
        )
        */
        if (!configSourceSideEffect)
            return;
        (0, utils_1.assert)('configValue' in configSourceSideEffect);
        const { configValue, configDefinedByFile } = configSourceSideEffect;
        const configMod = configDef.sideEffect({
            configValue,
            configDefinedBy: configDefinedByFile // TODO: align naming
        });
        if (!configMod)
            return;
        (0, utils_1.objectEntries)(configMod).forEach(([configName, configModValue]) => {
            if (configName === 'configDefinitions') {
                (0, utils_1.assertUsage)((0, utils_1.isObject)(configModValue), 'TODO');
                (0, utils_1.objectEntries)(configModValue).forEach(([configTargetName, configTargetModValue]) => {
                    (0, utils_1.assertUsage)((0, utils_1.isObject)(configTargetModValue), 'TODO');
                    (0, utils_1.assertUsage)(Object.keys(configTargetModValue).length === 1, 'TODO');
                    (0, utils_1.assertUsage)((0, utils_1.hasProp)(configTargetModValue, 'c_env', 'string'), 'TODO');
                    const c_env = configTargetModValue.c_env; // TODO: proper validation
                    configSourcesMod[configTargetName].c_env = c_env;
                });
            }
            else {
                const configDef = configDefinitionsRelevant[configName];
                (0, utils_1.assertUsage)(configDef, `sideEffect of TODO returns unknown config '${configName}'`);
                const configSourceTargetOld = configSourcesMod[configName];
                (0, utils_1.assert)(configSourceTargetOld);
                configSourcesMod[configName] = {
                    // TODO-begin
                    ...configSourceSideEffect,
                    configSrc: `${configSourceSideEffect} (side-effect)`,
                    // TODO-end
                    c_env: configSourceTargetOld.c_env,
                    configValue: configModValue
                };
            }
        });
    });
    return configSourcesMod;
}
async function findAndLoadConfigValueFiles(configDefinitionsAll, userRootDir) {
    const found = await findUserFiles('**/+*', userRootDir);
    const configValueFiles = await Promise.all(found
        .filter((f) => extractConfigName(f.filePathRelativeToUserRootDir) !== 'config')
        .map(async ({ filePathAbsolute, filePathRelativeToUserRootDir }) => {
        const configName = extractConfigName(filePathRelativeToUserRootDir);
        const configDef = configDefinitionsAll[configName];
        (0, utils_1.assertUsage)(configDef, `${configName} sets an unknown config '${configName}'`);
        const configValueFile = {
            configName,
            pageId: (0, deduceRouteStringFromFilesystemPath_1.determinePageId2)(filePathRelativeToUserRootDir),
            configValueFilePath: filePathRelativeToUserRootDir
        };
        if (configDef.c_env !== 'c_config') {
            return configValueFile;
        }
        const result = await (0, utils_1.transpileAndLoadScriptFile)(filePathAbsolute);
        if ('err' in result) {
            throw result.err;
        }
        const fileExports = result.exports;
        (0, utils_1.assertDefaultExport)(fileExports, filePathRelativeToUserRootDir);
        const configValue = fileExports.default;
        (0, utils_1.objectAssign)(configValueFile, { configValue });
        return configValueFile;
    }));
    return configValueFiles;
}
function extractConfigName(filePath) {
    (0, utils_1.assertPosixPath)(filePath);
    const basename = path_1.default.posix.basename(filePath).split('.')[0];
    (0, utils_1.assert)(basename.startsWith('+'));
    const configName = basename.slice(1);
    return configName;
}
async function findAndLoadPageConfigFiles1(userRootDir) {
    const pageConfigFilePaths = await findUserFiles(`**/+config.${utils_1.scriptFileExtensions}`, userRootDir);
    const pageConfigFiles = [];
    // TODO: make esbuild build everyting at once
    const results = await Promise.all(pageConfigFilePaths.map(async ({ filePathAbsolute, filePathRelativeToUserRootDir }) => {
        const result = await (0, utils_1.transpileAndLoadScriptFile)(filePathAbsolute);
        if ('err' in result) {
            return { err: result.err };
        }
        return { pageConfigFilePath: filePathRelativeToUserRootDir, pageConfigFileExports: result.exports };
    }));
    for (const result of results) {
        if ('err' in result) {
            (0, utils_1.assert)(result.err);
            return {
                err: result.err
            };
        }
    }
    results.forEach((result) => {
        (0, utils_1.assert)(!('err' in result));
        const { pageConfigFilePath, pageConfigFileExports } = result;
        pageConfigFiles.push({
            pageConfigFilePath,
            pageConfigFileExports
        });
    });
    return { pageConfigFiles };
}
async function findUserFiles(pattern, userRootDir) {
    (0, utils_1.assertPosixPath)(userRootDir);
    const timeBase = new Date().getTime();
    const result = await (0, fast_glob_1.default)(pattern, {
        ignore: ['**/node_modules/**'],
        cwd: userRootDir,
        dot: false
    });
    const time = new Date().getTime() - timeBase;
    (0, utils_1.assertWarning)(time < 2 * 1000, `Crawling your user files took an unexpected long time (${time}ms). Create a new issue on vite-plugin-ssr's GitHub.`, {
        showStackTrace: false,
        onlyOnce: 'slow-page-files-search'
    });
    const userFiles = result.map((p) => {
        p = (0, utils_1.toPosixPath)(p);
        const filePathRelativeToUserRootDir = path_1.default.posix.join('/', p);
        const filePathAbsolute = path_1.default.posix.join(userRootDir, p);
        return { filePathRelativeToUserRootDir, filePathAbsolute };
    });
    return userFiles;
}
function handleBuildError(err, isDev) {
    // Properly handle error during transpilation so that we can use assertUsage() during transpilation
    if (isDev) {
        throw err;
    }
    else {
        // Avoid ugly error format:
        // ```
        // [vite-plugin-ssr:virtualModulePageFiles] Could not load virtual:vite-plugin-ssr:pageFiles:server: [vite-plugin-ssr@0.4.70][Wrong Usage] /pages/+config.ts sets the config 'onRenderHtml' to the value './+config/onRenderHtml-i-dont-exist.js' but no file was found at /home/rom/code/vite-plugin-ssr/examples/v1/pages/+config/onRenderHtml-i-dont-exist.js
        // Error: [vite-plugin-ssr@0.4.70][Wrong Usage] /pages/+config.ts sets the config 'onRenderHtml' to the value './+config/onRenderHtml-i-dont-exist.js' but no file was found at /home/rom/code/vite-plugin-ssr/examples/v1/pages/+config/onRenderHtml-i-dont-exist.js
        //     at resolveCodeFilePath (/home/rom/code/vite-plugin-ssr/vite-plugin-ssr/dist/cjs/node/plugin/plugins/generateImportGlobs/file.js:203:33)
        //     at /home/rom/code/vite-plugin-ssr/vite-plugin-ssr/dist/cjs/node/plugin/plugins/generateImportGlobs/file.js:100:38
        //     ...
        //   code: 'PLUGIN_ERROR',
        //   plugin: 'vite-plugin-ssr:virtualModulePageFiles',
        //   hook: 'load',
        //   watchFiles: [
        //     '/home/rom/code/vite-plugin-ssr/vite-plugin-ssr/dist/cjs/node/importBuild.js',
        //     '\x00virtual:vite-plugin-ssr:pageFiles:server'
        //   ]
        // }
        //  ELIFECYCLE  Command failed with exit code 1.
        // ```
        console.log('');
        console.error(err);
        process.exit(1);
    }
}
function getPageConfigFilesRelevant(pageId, pageConfigFiles) {
    const pageConfigFilesRelevant = pageConfigFiles.filter(({ pageConfigFilePath }) => {
        (0, utils_1.assertPosixPath)(pageConfigFilePath);
        (0, utils_1.assert)(pageConfigFilePath.startsWith('/'));
        const configFsRoot = pageConfigFilePath
            .split('/')
            .filter((p) => p !== 'renderer')
            .slice(0, -1) // remove filename +config.js
            .join('/');
        return pageId.startsWith(configFsRoot);
    });
    return pageConfigFilesRelevant;
}
