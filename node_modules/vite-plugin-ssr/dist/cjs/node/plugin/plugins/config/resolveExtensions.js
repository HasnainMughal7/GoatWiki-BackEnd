"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveExtensions = void 0;
const utils_1 = require("../../utils");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const fileTypes_1 = require("../../../../shared/getPageFiles/fileTypes");
function resolveExtensions(configs, config) {
    const extensions = configs.map((c) => c.extensions ?? []).flat();
    return extensions.map((extension) => {
        const { npmPackageName } = extension;
        (0, utils_1.assertUsage)((0, utils_1.isNpmPackageName)(npmPackageName), `Extension '${npmPackageName}' doesn't seem to be a valid npm package name`);
        const npmPackageRootDir = (0, utils_1.getDependencyRootDir)(npmPackageName, config.root);
        (0, utils_1.assertPosixPath)(npmPackageRootDir);
        const pageFilesDist = resolvePageFilesDist(extension.pageFilesDist, npmPackageName, config, npmPackageRootDir);
        let pageFilesSrc = null;
        if (extension.pageFilesSrc) {
            assertPathProvidedByUser('pageFilesSrc', extension.pageFilesSrc, true);
            (0, utils_1.assert)(extension.pageFilesSrc.endsWith('*'));
            pageFilesSrc = path_1.default.posix.join(npmPackageRootDir, extension.pageFilesSrc.slice(0, -1));
        }
        (0, utils_1.assertUsage)((pageFilesSrc || pageFilesDist) && (!pageFilesDist || !pageFilesSrc), `Extension ${npmPackageName} should define either extension[number].pageFilesDist or extension[number].pageFilesSrc (at least one but not both)`);
        const assetsDir = (() => {
            if (!extension.assetsDir) {
                return null;
            }
            assertPathProvidedByUser('assetsDir', extension.assetsDir);
            (0, utils_1.assertPosixPath)(extension.assetsDir);
            const assetsDir = path_1.default.posix.join(npmPackageRootDir, extension.assetsDir);
            return assetsDir;
        })();
        (0, utils_1.assertUsage)(!(assetsDir && pageFilesSrc), `Extension ${npmPackageName} shouldn't define both extension[number].pageFilesSrc and extension[number].assetsDir`);
        const extensionResolved = {
            npmPackageName,
            npmPackageRootDir,
            pageFilesDist,
            pageFilesSrc,
            assetsDir
        };
        return extensionResolved;
    });
}
exports.resolveExtensions = resolveExtensions;
function assertPathProvidedByUser(pathName, pathValue, starSuffix) {
    const errMsg = `extension[number].${pathName} value '${pathValue}'`;
    (0, utils_1.assertUsage)(!pathValue.includes('\\'), `${errMsg} shouldn't contain any backward slahes '\' (replace them with forward slahes '/')`);
    (0, utils_1.assertUsage)(!starSuffix || pathValue.endsWith('/*'), `${errMsg} should end with '/*'`);
    (0, utils_1.assertUsage)(pathValue.startsWith('/'), `${errMsg} should start with '/'`);
}
function resolvePageFilesDist(pageFilesDist, npmPackageName, config, npmPackageRootDir) {
    if (!pageFilesDist)
        return null;
    const pageFilesDistResolved = [];
    pageFilesDist.forEach((importPath) => {
        const errPrefix = `The page file '${importPath}' (provided in extensions[number].pageFiles) should`;
        (0, utils_1.assertUsage)(npmPackageName === (0, utils_1.getNpmPackageName)(importPath), `${errPrefix} be a ${npmPackageName} module (e.g. '${npmPackageName}/renderer/_default.page.server.js')`);
        (0, utils_1.assertUsage)((0, fileTypes_1.isValidFileType)(importPath), `${errPrefix} end with '.js', '.mjs', '.cjs', or '.css'`);
        const filePath = resolveImportPath(importPath, npmPackageName, config, npmPackageRootDir);
        pageFilesDistResolved.push({
            importPath,
            filePath
        });
        const filePathCSS = getPathCSS(filePath);
        if (filePathCSS !== filePath && fs_1.default.existsSync(filePathCSS)) {
            const importPathCSS = getPathCSS(importPath);
            (0, utils_1.assertUsage)(filePathCSS === resolveImportPath(importPathCSS, npmPackageName, config, npmPackageRootDir), `The entry package.json#exports["${importPathCSS}"] in the package.json of ${npmPackageName} (${npmPackageRootDir}/package.json) has a wrong value: make sure it resolves to ${filePathCSS}`);
            pageFilesDistResolved.push({
                importPath: importPathCSS,
                filePath: filePathCSS
            });
        }
    });
    return pageFilesDistResolved;
}
function resolveImportPath(importPath, npmPackageName, config, npmPackageRootDir) {
    let filePath;
    try {
        filePath = require.resolve(importPath, { paths: [config.root] });
    }
    catch (err) {
        if (err?.code === 'ERR_PACKAGE_PATH_NOT_EXPORTED') {
            (0, utils_1.assertUsage)(false, `Define ${importPath} in the package.json#exports of ${npmPackageName} (${npmPackageRootDir}/package.json) with a Node.js export condition (even if it's a browser file such as CSS)`);
        }
        throw err;
    }
    filePath = (0, utils_1.toPosixPath)(filePath);
    return filePath;
}
function getPathCSS(filePath) {
    return filePath.split('.').slice(0, -1).join('.') + '.css';
}
