"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRenderContext = exports.initPageContext = exports.loadPageFilesServer = exports.prerender404Page = exports.prerenderPageContext = exports.renderPageContext = void 0;
const route_1 = require("../../../shared/route");
const renderHtml_1 = require("../html/renderHtml");
const getPageFiles_1 = require("../../../shared/getPageFiles");
const getHook_1 = require("../../../shared/getHook");
const utils_1 = require("../../utils");
const assertHookResult_1 = require("../../../shared/assertHookResult");
const stream_1 = require("../html/stream");
const helpers_1 = require("../helpers");
const addComputedUrlProps_1 = require("../../../shared/addComputedUrlProps");
const assertPageContextProvidedByUser_1 = require("../../../shared/assertPageContextProvidedByUser");
const globalContext_1 = require("../globalContext");
const createHttpResponseObject_1 = require("./createHttpResponseObject");
const logError_1 = require("./logError");
const loadPageFilesServer_1 = require("./loadPageFilesServer");
Object.defineProperty(exports, "loadPageFilesServer", { enumerable: true, get: function () { return loadPageFilesServer_1.loadPageFilesServer; } });
const preparePageContextForRelease_1 = require("./preparePageContextForRelease");
const handleErrorWithoutErrorPage_1 = require("./handleErrorWithoutErrorPage");
async function renderPageContext(pageContext) {
    const isError = pageContext.is404 || pageContext.errorWhileRendering;
    if (isError) {
        (0, utils_1.assert)(pageContext._pageId === null);
        const errorPageId = (0, route_1.getErrorPageId)(pageContext._pageFilesAll, pageContext._pageConfigs);
        if (errorPageId) {
            (0, utils_1.objectAssign)(pageContext, { _pageId: errorPageId });
        }
        else {
            // The user hasn't define a `_error.page.js`
            (0, utils_1.objectAssign)(pageContext, { _pageId: null });
            return (0, handleErrorWithoutErrorPage_1.handleErrorWithoutErrorPage)(pageContext);
        }
    }
    // We now resolved `pageContext._pageId`. It can either be the:
    //  - ID of the page matching the routing, or the
    //  - ID of the error page `_error.page.js`.
    (0, utils_1.assert)((0, utils_1.hasProp)(pageContext, '_pageId', 'string'));
    const pageFiles = await (0, loadPageFilesServer_1.loadPageFilesServer)(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    if (!isError) {
        await executeOnBeforeRenderHooks(pageContext);
    }
    else {
        try {
            await executeOnBeforeRenderHooks(pageContext);
        }
        catch (err) {
            if ((0, logError_1.isNewError)(err, pageContext.errorWhileRendering)) {
                (0, logError_1.logErrorWithVite)(err);
            }
        }
    }
    if (pageContext._isPageContextRequest) {
        if (isError) {
            (0, utils_1.objectAssign)(pageContext, { _isError: true });
        }
        const body = (0, helpers_1.serializePageContextClientSide)(pageContext);
        const httpResponse = await (0, createHttpResponseObject_1.createHttpResponseObject)(body, null, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
    const renderHookResult = await executeOnRenderHtmlHook(pageContext);
    if (renderHookResult.htmlRender === null) {
        (0, utils_1.objectAssign)(pageContext, { httpResponse: null });
        return pageContext;
    }
    else {
        const { htmlRender, renderSrc } = renderHookResult;
        const httpResponse = await (0, createHttpResponseObject_1.createHttpResponseObject)(htmlRender, renderSrc, pageContext);
        (0, utils_1.objectAssign)(pageContext, { httpResponse });
        return pageContext;
    }
}
exports.renderPageContext = renderPageContext;
async function prerenderPageContext(pageContext) {
    (0, utils_1.objectAssign)(pageContext, {
        _isPageContextRequest: false,
        _urlHandler: null
    });
    (0, addComputedUrlProps_1.addComputedUrlProps)(pageContext);
    await executeOnBeforeRenderHooks(pageContext);
    const renderHookResult = await executeOnRenderHtmlHook(pageContext);
    (0, utils_1.assertUsage)(renderHookResult.htmlRender !== null, `Cannot pre-render \`${pageContext.urlOriginal}\` because the \`render()\` hook defined by ${renderHookResult.renderSrc} didn't return an HTML string.`);
    (0, utils_1.assert)(pageContext._isPageContextRequest === false);
    const documentHtml = await (0, renderHtml_1.getHtmlString)(renderHookResult.htmlRender);
    (0, utils_1.assert)(typeof documentHtml === 'string');
    if (!pageContext._usesClientRouter) {
        return { documentHtml, pageContextSerialized: null, pageContext };
    }
    else {
        const pageContextSerialized = (0, helpers_1.serializePageContextClientSide)(pageContext);
        return { documentHtml, pageContextSerialized, pageContext };
    }
}
exports.prerenderPageContext = prerenderPageContext;
async function prerender404Page(renderContext, pageContextInit_) {
    const errorPageId = (0, route_1.getErrorPageId)(renderContext.pageFilesAll, renderContext.pageConfigs);
    if (!errorPageId) {
        return null;
    }
    const pageContext = {};
    const pageContextInit = {
        urlOriginal: '/fake-404-url',
        ...pageContextInit_
    };
    {
        const pageContextInitAddendum = initPageContext(pageContextInit, renderContext);
        (0, utils_1.objectAssign)(pageContext, pageContextInitAddendum);
    }
    (0, utils_1.objectAssign)(pageContext, {
        _pageId: errorPageId,
        is404: true,
        routeParams: {},
        // `prerender404Page()` is about generating `dist/client/404.html` for static hosts; there is no Client Routing.
        _usesClientRouter: false,
        _routeMatches: []
    });
    const pageFiles = await (0, loadPageFilesServer_1.loadPageFilesServer)(pageContext);
    (0, utils_1.objectAssign)(pageContext, pageFiles);
    return prerenderPageContext(pageContext);
}
exports.prerender404Page = prerender404Page;
function initPageContext(pageContextInit, renderContext) {
    (0, utils_1.assert)(pageContextInit.urlOriginal);
    const globalContext = (0, globalContext_1.getGlobalContext)();
    const pageContextAddendum = {
        ...pageContextInit,
        _objectCreatedByVitePluginSsr: true,
        _pageFilesAll: renderContext.pageFilesAll,
        _pageConfigs: renderContext.pageConfigs,
        _allPageIds: renderContext.allPageIds,
        // The following is defined on `pageContext` because we can eventually make these non-global (e.g. sot that two pages can have different includeAssetsImportedByServer settings)
        _baseServer: globalContext.baseServer,
        _baseAssets: globalContext.baseAssets,
        _includeAssetsImportedByServer: globalContext.includeAssetsImportedByServer
    };
    return pageContextAddendum;
}
exports.initPageContext = initPageContext;
// TODO: remove getRenderContext() in favor of getGlobalObject() + reloadGlobalContext()
async function getRenderContext() {
    const globalContext = (0, globalContext_1.getGlobalContext)();
    const { pageFilesAll, allPageIds, pageConfigs } = await (0, getPageFiles_1.getPageFilesAll)(false, globalContext.isProduction);
    assertNonMixedDesign(pageFilesAll, pageConfigs);
    const renderContext = {
        pageFilesAll: pageFilesAll,
        pageConfigs,
        allPageIds: allPageIds
    };
    return renderContext;
}
exports.getRenderContext = getRenderContext;
function assertNonMixedDesign(pageFilesAll, pageConfigs) {
    if (pageFilesAll.length === 0 || pageConfigs.length === 0)
        return;
    const indent = '- ';
    const v1Files = (0, utils_1.unique)(pageConfigs.map((p) => Object.values(p.configSources).map((c) => indent + c.configDefinedByFile)).flat());
    (0, utils_1.assertUsage)(false, [
        'Mixing the new V1 design with the old V0.4 design is forbidden.',
        'V1 files:',
        ...v1Files,
        'V0.4 files:',
        ...pageFilesAll.map((p) => indent + p.filePath)
    ].join('\n'));
}
async function executeOnBeforeRenderHooks(pageContext) {
    if (pageContext._pageContextAlreadyProvidedByOnPrerenderHook) {
        return;
    }
    const hook = (0, getHook_1.getHook)(pageContext, 'onBeforeRender');
    if (!hook) {
        return;
    }
    const onBeforeRender = hook.hook;
    (0, preparePageContextForRelease_1.preparePageContextForRelease)(pageContext);
    const hookResult = await (0, utils_1.callHookWithTimeout)(() => onBeforeRender(pageContext), 'onBeforeRender', hook.hookSrc);
    (0, assertHookResult_1.assertHookResult)(hookResult, 'onBeforeRender', ['pageContext'], hook.hookSrc);
    const pageContextFromHook = hookResult?.pageContext;
    Object.assign(pageContext, pageContextFromHook);
}
async function executeOnRenderHtmlHook(pageContext) {
    let hook = null;
    {
        const renderHook = (0, getHook_1.getHook)(pageContext, 'render');
        // assertWarning(!renderHook, 'Hook render() has been renamed to onRenderHtml() and onRenderClient()', { onlyOnce: true, showStackTrace: false }) // TODO/v1: replace this warning with waning that user should migrate to v1
        hook = renderHook;
    }
    {
        const renderHook = (0, getHook_1.getHook)(pageContext, 'onRenderHtml');
        if (renderHook) {
            hook = renderHook;
        }
    }
    (0, utils_1.assertUsage)(hook, [
        //'No onRenderHtml() hook found.',
        'No render() hook found.',
        'See https://vite-plugin-ssr.com/render-modes for more information.',
        [
            // 'Loaded config files (none of them define the onRenderHtml() hook):',
            'Loaded server-side page files (none of them `export { render }`):',
            ...pageContext._pageFilePathsLoaded.map((f, i) => ` (${i + 1}): ${f}`)
        ].join('\n')
    ].join(' '));
    const render = hook.hook;
    const renderSrc = hook.hookSrc;
    (0, preparePageContextForRelease_1.preparePageContextForRelease)(pageContext);
    const result = await (0, utils_1.callHookWithTimeout)(() => render(pageContext), 'render', renderSrc);
    if ((0, utils_1.isObject)(result) && !(0, renderHtml_1.isDocumentHtml)(result)) {
        (0, assertHookResult_1.assertHookResult)(result, 'render', ['documentHtml', 'pageContext', 'injectFilter'], renderSrc, true);
    }
    (0, utils_1.objectAssign)(pageContext, { _renderHook: { hookSrc: renderSrc, hookName: 'render' } });
    const errPrefix = 'The render() hook defined by ' + renderSrc;
    let pageContextPromise = null;
    if ((0, utils_1.hasProp)(result, 'pageContext')) {
        const pageContextProvidedByRenderHook = result.pageContext;
        if ((0, utils_1.isPromise)(pageContextProvidedByRenderHook) || (0, utils_1.isCallable)(pageContextProvidedByRenderHook)) {
            (0, utils_1.assertWarning)(!(0, utils_1.isPromise)(pageContextProvidedByRenderHook), `${errPrefix} returns a pageContext promise which is deprecated in favor of returning a pageContext async function, see https://vite-plugin-ssr.com/stream#initial-data-after-stream-end`, { onlyOnce: true, showStackTrace: false });
            pageContextPromise = pageContextProvidedByRenderHook;
        }
        else {
            (0, assertPageContextProvidedByUser_1.assertPageContextProvidedByUser)(pageContextProvidedByRenderHook, { hook: pageContext._renderHook });
            Object.assign(pageContext, pageContextProvidedByRenderHook);
        }
    }
    (0, utils_1.objectAssign)(pageContext, { _pageContextPromise: pageContextPromise });
    const errSuffix = [
        'a string generated with the `escapeInject` template tag or a string returned by `dangerouslySkipEscape()`,',
        'see https://vite-plugin-ssr.com/escapeInject'
    ].join(' ');
    let documentHtml;
    if (!(0, utils_1.isObject)(result) || (0, renderHtml_1.isDocumentHtml)(result)) {
        (0, utils_1.assertUsage)(typeof result !== 'string', [
            errPrefix,
            'returned a plain JavaScript string which is forbidden;',
            'instead, it should return',
            errSuffix
        ].join(' '));
        (0, utils_1.assertUsage)(result === null || (0, renderHtml_1.isDocumentHtml)(result), [
            errPrefix,
            'should return `null`, a string `documentHtml`, or an object `{ documentHtml, pageContext }`',
            'where `pageContext` is `undefined` or an object holding additional `pageContext` values',
            'and `documentHtml` is',
            errSuffix
        ].join(' '));
        documentHtml = result;
    }
    else {
        if ('documentHtml' in result) {
            documentHtml = result.documentHtml;
            (0, utils_1.assertUsage)(typeof documentHtml !== 'string', [
                errPrefix,
                'returned `{ documentHtml }`, but `documentHtml` is a plain JavaScript string which is forbidden;',
                '`documentHtml` should be',
                errSuffix
            ].join(' '));
            (0, utils_1.assertUsage)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml), [errPrefix, 'returned `{ documentHtml }`, but `documentHtml` should be', errSuffix].join(' '));
        }
    }
    (0, utils_1.assert)(documentHtml === undefined || documentHtml === null || (0, renderHtml_1.isDocumentHtml)(documentHtml));
    if (documentHtml === null || documentHtml === undefined) {
        return { htmlRender: null, renderSrc };
    }
    const onErrorWhileStreaming = (err) => {
        (0, logError_1.logErrorWithVite)(err);
        /*
        objectAssign(pageContext, {
          errorWhileRendering: err,
          _serverSideErrorWhileStreaming: true
        })
        */
    };
    let injectFilter = null;
    if ((0, utils_1.hasProp)(result, 'injectFilter')) {
        (0, utils_1.assertUsage)((0, utils_1.isCallable)(result.injectFilter), 'injectFilter should be a function');
        injectFilter = result.injectFilter;
    }
    const htmlRender = await (0, renderHtml_1.renderDocumentHtml)(documentHtml, pageContext, renderSrc, onErrorWhileStreaming, injectFilter);
    (0, utils_1.assert)(typeof htmlRender === 'string' || (0, stream_1.isStream)(htmlRender));
    return { htmlRender, renderSrc };
}
